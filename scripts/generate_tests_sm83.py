import os, sys
import json

script_path = sys.argv[0]
tests_path = sys.argv[1]
repository_path = sys.argv[2]

assert os.path.exists(f"{repository_path}/v1/00.json"), "sm83 directory is not checked out"

SUPPORTED_OPCODES = ([
    (0x00,"nop"), # NOP
    (0x01,"ld"), # LD BC, nnnn
    (0x02,"ld"), # LD [BC], A
    (0x0A,"ld"), # LD A, [BC]
    (0x11,"ld"), # LD DE, nnnn
    (0x12,"ld"), # LD [DE], A
    (0x1A,"ld"), # LD A, [DE]
    (0x21,"ld"), # LD HL, nnnn
    (0x22,"ld"), # LD HL+, A
    (0x2A,"ld"), # LD A, [HL+]
    (0x31,"ld"), # LD SP, nnnn
    (0x32,"ld"), # LD HL-, A
    (0x3A,"ld"), # LD A, [HL-]
    # 0x40 to 0x7F is the main load block
    (0x40,"ld"), # LD B, B
    (0x41,"ld"), # LD B, C
    (0x42,"ld"), # LD B, D
    (0x43,"ld"), # LD B, E
    (0x44,"ld"), # LD B, H
    (0x45,"ld"), # LD B, L
    (0x46,"ld"), # LD B, [HL]
    (0x47,"ld"), # LD B, A
    (0x48,"ld"), # LD C, B
    (0x49,"ld"), # LD C, C
    (0x4A,"ld"), # LD C, D
    (0x4B,"ld"), # LD C, E
    (0x4C,"ld"), # LD C, H
    (0x4D,"ld"), # LD C, L
    (0x4E,"ld"), # LD C, [HL]
    (0x4F,"ld"), # LD C, A
    (0x50,"ld"), # LD D, B
    (0x51,"ld"), # LD D, C
    (0x52,"ld"), # LD D, D
    (0x53,"ld"), # LD D, E
    (0x54,"ld"), # LD D, H
    (0x55,"ld"), # LD D, L
    (0x56,"ld"), # LD D, [HL]
    (0x57,"ld"), # LD D, A
    (0x58,"ld"), # LD E, B
    (0x59,"ld"), # LD E, C
    (0x5A,"ld"), # LD E, D
    (0x5B,"ld"), # LD E, E
    (0x5C,"ld"), # LD E, H
    (0x5D,"ld"), # LD E, L
    (0x5E,"ld"), # LD E, [HL]
    (0x5F,"ld"), # LD E, A
    (0x60,"ld"), # LD H, B
    (0x61,"ld"), # LD H, C
    (0x62,"ld"), # LD H, D
    (0x63,"ld"), # LD H, E
    (0x64,"ld"), # LD H, H
    (0x65,"ld"), # LD H, L
    (0x66,"ld"), # LD H, [HL]
    (0x67,"ld"), # LD H, A
    (0x68,"ld"), # LD L, B
    (0x69,"ld"), # LD L, C
    (0x6A,"ld"), # LD L, D
    (0x6B,"ld"), # LD L, E
    (0x6C,"ld"), # LD L, H
    (0x6D,"ld"), # LD L, L
    (0x6E,"ld"), # LD L, [HL]
    (0x6F,"ld"), # LD L, A
    (0x70,"ld"), # LD [HL], B
    (0x71,"ld"), # LD [HL], C
    (0x72,"ld"), # LD [HL], D
    (0x73,"ld"), # LD [HL], E
    (0x74,"ld"), # LD [HL], H
    (0x75,"ld"), # LD [HL], L
    # 0x76 is HALT ('ld [hl], [hl]')
    (0x77,"ld"), # LD [HL], A
    (0x78,"ld"), # LD A, B
    (0x79,"ld"), # LD A, C
    (0x7A,"ld"), # LD A, D
    (0x7B,"ld"), # LD A, E
    (0x7C,"ld"), # LD A, H
    (0x7D,"ld"), # LD A, L
    (0x7E,"ld"), # LD A, [HL]
    (0x7F,"ld"), # LD A, A
])

for info in SUPPORTED_OPCODES:
    opcode = info[0]
    insn = info[1]
    input_filename = os.path.join(f"{repository_path}/v1", (f"{opcode:02X}.json").lower())
    output_filename = f"{tests_path}/sm83_{opcode:02X}.cpp"
    with open(input_filename, "r") as input_fn, open(output_filename, "w", encoding="utf-8") as output_fn:
        input_json = json.load(input_fn)

        output_fn.write(f"// File autogenerated by {script_path}\n")
        output_fn.write(f"#include <test/include/acutest.h>\n\n")
        output_fn.write(f"#include <cpu/include/instruction_{insn}.hpp>\n")
        output_fn.write(f"#include <cpu/include/registers.hpp>\n")
        output_fn.write(f"#include <memory/include/memory.hpp>\n\n")

        output_fn.write(f"using namespace pgb::common;\n")
        output_fn.write(f"using namespace pgb::memory;\n")
        output_fn.write(f"using namespace pgb::cpu;\n\n")

        output_fn.write(f"static auto registers = RegisterFile();\n")
        output_fn.write(f"static auto mmap      = MemoryMap(registers, MaxRomBankCount, MaxVramBankCount, MaxEramBankCount, MaxWramBankCount);\n\n")

        output_fn.write(f"""
#define WriteRegisterWord(register, value) do {{ auto result = mmap.WriteWord(register, value); TEST_ASSERT(result.IsSuccess()); }} while(0)
#define WriteRegisterByte(register, value) do {{ auto result = mmap.WriteByte(register, value); TEST_ASSERT(result.IsSuccess()); }} while(0)
#define WriteRegisterFlag(value) do {{ TEST_ASSERT(static_cast<const Byte>(mmap.WriteFlagByte(static_cast<const Byte&>(value))) == 0x00); }} while(0)
#define WriteMemory(address, value) do {{ auto result = mmap.WriteByte(address, value); TEST_ASSERT(result.IsSuccess()); }} while(0)

#define CheckRegisterWord(register, value) do {{ auto result = mmap.ReadWord(register); TEST_ASSERT(result.IsSuccess()); TEST_ASSERT(static_cast<const Word&>(result) == value); }} while(0)
#define CheckRegisterByte(register, value) do {{ auto result = mmap.ReadByte(register); TEST_ASSERT(result.IsSuccess()); TEST_ASSERT(static_cast<const Byte&>(result) == value); }} while(0)
#define CheckRegisterFlag(value) do {{ TEST_ASSERT(static_cast<const Byte>(mmap.ReadFlagByte()) == value); }} while(0)
#define CheckMemory(address, value) do {{ auto result = mmap.ReadByte(address); TEST_ASSERT(result.IsSuccess()); TEST_ASSERT(static_cast<const Byte&>(result) == value); }} while(0)

static_assert(instruction::InstructionRegistryNoPrefix::Callbacks[0x{opcode:02X}] != nullptr);
static_assert(instruction::InstructionRegistryNoPrefix::Ticks[0x{opcode:02X}] != 0);
\n""")

        test_names = []
        test_content = []
        for test in input_json:
            skip_test = False
            test_name = test['name'].replace(' ', '_')
            test_names.append(test_name)
            test_content.append(f"""
void test_{test_name}()
{{
    if (skip_test_{test_name})
    {{
        TEST_SKIP("Skipping");
        return;
    }}
    mmap.Reset();
    TEST_ASSERT(mmap.Initialize(MaxRomBankCount, MaxVramBankCount, MaxEramBankCount, MaxWramBankCount).IsSuccess());

    // Initial state
""")
            # These tests assume '64K of flat ram (Address range from 0x0000 to 0xFFFF)
            # No point bank swapping, just assume raw data
            for val in test['initial']:
                if val in ("pc", "sp"):
                    address = test['initial'][val]
                    assert address <= 0xFFFF
                    if address >= 0xFEA0 and address <= 0xFEFF:
                        # Don't bother with tests that right to illegal locations'
                        skip_test = True
                    test_content.append(f"    WriteRegisterWord(RegisterType::{val.upper()}, 0x{address:04X});")
                elif val in ("a", "b", "c", "d", "e", "h", "l", "ie"):
                    test_content.append(f"    WriteRegisterByte(RegisterType::{val.upper()}, 0x{test['initial'][val]:02X});")
                elif val == 'f':
                    test_content.append(f"    WriteRegisterFlag(0x{test['initial'][val]:02X});")
                elif val == 'ime':
                    v = test['initial'][val]
                    assert v in (0, 1)
                    if v == 0:
                        test_content.append(f"    mmap.DisableIME();")
                    else:
                        test_content.append(f"    mmap.EnableIME();")
                elif val == "ram":
                    for ram in test['initial'][val]:
                        address = ram[0]
                        assert address <= 0xFFFF
                        if address >= 0xFEA0 and address <= 0xFEFF:
                            # Don't bother with tests that right to illegal locations'
                            skip_test = True
                        test_content.append(f"    WriteMemory(0x{ram[0]:04X}, 0x{ram[1]:02X});")

            test_content.append(f"""
    // Execute single step
    {{
         auto resultByte = mmap.ReadByte(mmap.ReadPC());
         TEST_ASSERT(resultByte.IsSuccess());
         auto ticks = instruction::InstructionRegistryNoPrefix::Execute(static_cast<const Byte&>(resultByte), mmap);
         TEST_ASSERT(ticks == instruction::InstructionRegistryNoPrefix::Ticks[static_cast<const Byte&>(resultByte)]);
         TEST_ASSERT(ticks == {len(test['cycles']) * 4});
    }}

    // Final state
            """)

            for val in test['final']:
                if val in ("pc", "sp"):
                    address = test['final'][val]
                    assert address <= 0xFFFF
                    if address >= 0xFEA0 and address <= 0xFEFF:
                        # Don't bother with tests that right to illegal locations'
                        skip_test = True
                    test_content.append(f"    WriteRegisterWord(RegisterType::{val.upper()}, 0x{address:04X});")
                elif val in ("a", "b", "c", "d", "e", "h", "l", "ie"):
                    test_content.append(f"    CheckRegisterByte(RegisterType::{val.upper()}, 0x{test['final'][val]:02X});")
                elif val == 'f':
                    test_content.append(f"    CheckRegisterFlag(0x{test['final'][val]:02X});")
                elif val == 'ime':
                    v = test['final'][val]
                    assert v in (0, 1)
                    if v == 0:
                        test_content.append(f"    TEST_ASSERT(!mmap.IMEEnabled());")
                    else:
                        test_content.append(f"    TEST_ASSERT(mmap.IMEEnabled());")
                elif val == "ram":
                    for ram in test['final'][val]:
                        address = ram[0]
                        assert address <= 0xFFFF
                        if address >= 0xFEA0 and address <= 0xFEFF:
                            # Don't bother with tests that right to illegal locations'
                            skip_test = True
                        test_content.append(f"    CheckMemory(0x{ram[0]:04X}, 0x{ram[1]:02X});")

            test_content.append(f"}}")
            output_fn.write(f"const bool skip_test_{test_name} = {'true' if skip_test else 'false'};\n")

        for name in test_names:
            output_fn.write(f"void test_{name}(void);\n")

        output_fn.write(f"TEST_LIST = {{\n")
        for name in test_names:
            output_fn.write(f"    {{ \"{name}\", test_{name} }},\n")
        output_fn.write(f"    {{NULL, NULL}}\n")
        output_fn.write(f"}};\n")

        for content in test_content:
            output_fn.write(content)
            output_fn.write("\n")
